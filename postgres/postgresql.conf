# =============================================================================
# PostgreSQL 16 — Production Configuration
# Target: 4 GB container memory limit on AWS EC2 t3.xlarge
# Workload: n8n workflow automation (OLTP, small-medium queries)
# =============================================================================
# Generated using PGTune recommendations for 4GB RAM, SSD storage, web workload
# Reference: https://pgtune.leopard.in.ua/
# =============================================================================

# --- Connection Settings ---
listen_addresses = '*'
port = 5432
max_connections = 60                    # n8n pool (20) + runners + admin headroom
                                        # Default 100 is wasteful; each conn uses ~5-10MB

# --- Memory ---
shared_buffers = 1GB                    # 25% of 4GB container limit (PG standard)
effective_cache_size = 3GB              # 75% of container memory; informs query planner
work_mem = 32MB                         # Per-sort/hash operation memory
                                        # Conservative: 60 conns × 32MB = 1.9GB worst case
                                        # n8n queries rarely trigger multiple sort ops
maintenance_work_mem = 256MB            # For VACUUM, CREATE INDEX, ALTER TABLE
                                        # 64MB default is too low for maintenance ops

# --- WAL (Write-Ahead Log) ---
wal_buffers = 64MB                      # Auto-tuned would be 32MB; slightly higher for bursts
min_wal_size = 256MB                    # Minimum WAL retention
max_wal_size = 1GB                      # Triggers checkpoint when reached
checkpoint_completion_target = 0.9      # Spread I/O over 90% of checkpoint interval
                                        # Reduces I/O spikes (PG docs recommend 0.9)

# --- Query Planner ---
random_page_cost = 1.1                  # SSD storage (default 4.0 is for spinning disks)
effective_io_concurrency = 200          # SSD can handle many concurrent I/O requests
                                        # Default 1 is for HDD; 200 is standard for SSD

# --- Parallelism ---
max_worker_processes = 4                # Match container CPU limit
max_parallel_workers_per_gather = 2     # Up to 2 parallel workers per query
max_parallel_workers = 4                # Total parallel workers
max_parallel_maintenance_workers = 2    # Parallel VACUUM/INDEX operations

# --- Background Writer ---
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0

# --- Logging ---
log_destination = 'stderr'
logging_collector = off                 # Let container runtime handle log collection
log_min_duration_statement = 1000       # Log queries taking > 1 second
log_line_prefix = '%m [%p] %q%u@%d '
log_statement = 'ddl'                   # Log DDL statements (CREATE, ALTER, DROP)
log_temp_files = 0                      # Log all temp file usage (performance debugging)

# --- Autovacuum ---
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 60                 # Check every 60s (default)
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50
autovacuum_vacuum_scale_factor = 0.05   # Vacuum after 5% of rows change (default 20%)
autovacuum_analyze_scale_factor = 0.05  # Analyze after 5% of rows change
                                        # n8n execution table grows fast; aggressive vacuum
                                        # prevents table bloat and maintains query perf

# --- Locale ---
timezone = 'Asia/Kolkata'
lc_messages = 'en_US.utf8'

# --- Statistics ---
default_statistics_target = 100         # Default; sufficient for n8n query patterns
track_activities = on
track_counts = on
track_io_timing = on                    # Essential for diagnosing I/O bottlenecks
